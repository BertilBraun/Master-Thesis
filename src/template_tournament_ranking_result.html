<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Results Visualization</title>
    <style>
        body,
        html {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f4;
            overflow-x: hidden;
        }

        #tree {
            width: 100%;
            display: flex;
            flex-direction: column-reverse;
            padding: 20px;
        }

        .level {
            display: flex;
            justify-content: space-evenly;
        }

        .node {
            width: 65px;
            padding: 10px;
            border: 1px solid black;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            white-space: nowrap;
        }

        .node:hover {
            background-color: #e3e3e3;
        }

        #container {
            display: none;
            width: 100%;
            flex-direction: row;
            overflow-y: auto;
        }

        .card {
            width: 50%;
            padding: 10px;
            border: 1px solid #ccc;
            margin-bottom: 50px;
            box-sizing: border-box;
            height: fit-content;
        }

        .preferred {
            background-color: #e6ffe6;
            /* Light green background for preferred profile */
        }
    </style>
</head>

<body>
    <h1 style="position: absolute; top: 0; left: 30px;">Tournament Tree</h1>
    <div id="tree">
    </div>
    <div id="container">
    </div>

    <script>
        const authorData = "{{authorData}}"; // Replace with actual JSON data
        const rankingResults = authorData.ranking_results;

        function buildTree() {
            /* The following code is the Python implementation of the tournament creation and ranking process. The tree should reflect the same structure as the one generated by the Python code. 
            
    current_round = extractions
    ranking_results: list[RankingResult] = []

    round_number = 0
    # Run the tournament until we have one winner
    while len(current_round) > 1:
        next_round: list[ExtractedProfile] = []
        round_number += 1

        # Pair profiles and determine winners for the next round
        for i in range(0, len(current_round) - 1, 2):
            ranking_result = compare_profiles(current_round[i], current_round[i + 1], evaluator)
            next_round.append(ranking_result.winner)
            ranking_results.append(ranking_result)

        # If odd number of profiles, last one automatically moves to the next round
        if len(current_round) % 2 == 1:
            next_round.append(current_round[-1])

        current_round = next_round
        */
            const treeDiv = document.getElementById('tree');

            var current_round = authorData.evaluation_result;
            var round_number = 0;
            var current_ranking_index = 0;
            var match_number = 0;

            const create_match_node = (index, match, is_passthrough) => {
                const node = document.createElement('div');
                node.className = 'node';
                node.textContent = `${is_passthrough ? 'Pass' : 'Match'} ${index + 1}`;
                node.onclick = () => showMatchDetails(match);
                return node;
            };

            while (current_round.length > 1) {
                var next_round = [];
                round_number += 1;
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level';

                for (var i = 0; i < current_round.length - 1; i += 2) {
                    var ranking_result = rankingResults[current_ranking_index];
                    current_ranking_index += 1;

                    levelDiv.appendChild(create_match_node(match_number, ranking_result, false));
                    match_number += 1;

                    next_round.push(ranking_result.profiles[ranking_result.preferred_profile]);
                }

                if (current_round.length % 2 == 1) {
                    levelDiv.appendChild(create_match_node(match_number, {
                        profiles: [current_round[current_round.length - 1]],
                        preferred_profile: 0,
                        reasoning: 'Only one profile left in the round.'
                    }, true));
                    match_number += 1;

                    next_round.push(current_round[current_round.length - 1]);
                }

                treeDiv.appendChild(levelDiv);
                current_round = next_round;
            }






            return;





            for (let levelCount = 1; levelCount <= levels; levelCount++) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level';
                const matches = rankingResults.slice(Math.pow(2, levelCount - 1) - 1, Math.pow(2, levelCount) - 1);
                matches.forEach((match, index) => {
                    const node = document.createElement('div');
                    node.className = 'node';
                    node.textContent = `${index + 1 + Math.pow(2, levelCount - 1) - 1}`;
                    node.onclick = () => showMatchDetails(rankingResults[index + Math.pow(2, levelCount - 1) - 1]);
                    levelDiv.appendChild(node);
                });
                treeDiv.appendChild(levelDiv);
            }
        }

        function showMatchDetails(match) {
            const container = document.getElementById('container');
            container.style.display = 'flex';
            container.innerHTML = '';

            match.profiles.forEach((profile, idx) => {
                const card = document.createElement('div');
                card.className = 'card';
                if (idx === match.preferred_profile) {
                    card.classList.add('preferred');
                    card.innerHTML = `
                        <h2>Profile ${idx + 1} (Preferred)</h2>
                    `;
                } else {
                    card.innerHTML = `
                        <h2>Profile ${idx + 1}</h2>
                    `;
                }
                card.innerHTML += `
                    <p><strong>Domain:</strong> ${profile.profile.domain}</p>
                    <ul>
                        ${profile.profile.competencies.map(comp => `<li><strong>${comp.name}:</strong> ${comp.description}</li>`).join('')}
                    </ul>
                    <p><strong>Model:</strong> ${profile.model}</p>
                    <p><strong>Extraction Function:</strong> ${profile.extraction_function}</p>
                    <p><strong>Extraction Time:</strong> ${profile.extraction_time}s</p>
                    <p><strong>Number of Examples:</strong> ${profile.number_of_examples}</p>
                `;
                if (idx === match.preferred_profile) {
                    card.innerHTML += `<p><strong>Reasoning:</strong>${match.reasoning}</p>
                    `;
                }
                container.appendChild(card);
            });
        }

        buildTree();
    </script>
</body>

</html>
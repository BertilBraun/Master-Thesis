<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Results Visualization</title>
    <style>
        body,
        html {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f4;
            overflow-x: hidden;
        }

        #tree {
            width: 100%;
            display: flex;
            flex-direction: column-reverse;
            padding: 20px;
        }

        .level {
            display: flex;
            justify-content: space-evenly;
        }

        .node {
            width: 65px;
            padding: 10px;
            border: 1px solid black;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            white-space: nowrap;
        }

        .node:hover {
            background-color: #e3e3e3;
        }

        #container {
            display: none;
            width: 100%;
            flex-direction: row;
            overflow-y: auto;
        }

        .card {
            width: 50%;
            padding: 10px;
            border: 1px solid #ccc;
            margin-bottom: 50px;
            box-sizing: border-box;
            height: fit-content;
        }

        .preferred {
            background-color: #e6ffe6;
            /* Light green background for preferred profile */
        }
    </style>
</head>

<body>
    <h1 style="position: absolute; top: 0; left: 30px;">Tournament Tree</h1>
    <canvas id="graphCanvas" width="800" height="600"></canvas>
    <div id="container">
    </div>

    <script>
        const authorData = "{{authorData}}"; // Replace with actual JSON data
        const rankingResults = authorData.ranking_results;

        function buildTree() {
            /* The following code is the Python implementation of the tournament creation and ranking process. The tree should reflect the same structure as the one generated by the Python code. 
            
            current_round = extractions
            ranking_results: list[RankingResult] = []

            round_number = 0
            # Run the tournament until we have one winner
            while len(current_round) > 1:
                next_round: list[ExtractedProfile] = []
                round_number += 1

                # Pair profiles and determine winners for the next round
                for i in range(0, len(current_round) - 1, 2):
                    ranking_result = compare_profiles(current_round[i], current_round[i + 1], evaluator)
                    next_round.append(ranking_result.winner)
                    ranking_results.append(ranking_result)

                # If odd number of profiles, last one automatically moves to the next round
                if len(current_round) % 2 == 1:
                    next_round.append(current_round[-1])

                current_round = next_round
            */
            function Node(match, index) {
                this.match = match;
                this.index = index;
                this.children = [];
                this.x = -1; // X position to be set based on layout
                this.y = -1; // Y position to be set based on layout
                this.radius = 20; // Node radius
            }

            if (authorData.evaluation_result.length === 0) {
                return alert('No evaluation results to display.');
            }

            var last_round = [];
            var last_round_index = 0;
            var current_round = authorData.evaluation_result;
            var round_number = 0;
            var current_ranking_index = 0;
            var match_number = 0;

            const push_child = (node) => {
                if (last_round.length > last_round_index) {
                    node.children.push(last_round[last_round_index]);
                    last_round_index += 1;
                }
            };

            while (current_round.length > 1) {
                console.log(last_round)
                var next_round = [];
                var next_last_round = [];
                round_number += 1;

                for (var i = 0; i < current_round.length - 1; i += 2) {
                    const ranking_result = rankingResults[current_ranking_index];
                    current_ranking_index += 1;

                    const matchNode = new Node(ranking_result, match_number);
                    push_child(matchNode);
                    push_child(matchNode);
                    next_last_round.push(matchNode);

                    match_number += 1;

                    next_round.push(ranking_result.profiles[ranking_result.preferred_profile]);
                }

                if (current_round.length % 2 == 1) {
                    const matchNode = new Node({
                        profiles: [current_round[current_round.length - 1]],
                        preferred_profile: 0,
                        reasoning: 'Only one profile left in the round.'
                    }, match_number);
                    push_child(matchNode);

                    match_number += 1;

                    next_round.push(current_round[current_round.length - 1]);
                }

                last_round = next_last_round;
                last_round_index = 0;
                current_round = next_round;
            }

            const root = last_round[0];

            function getLeaves(node) {
                if (node.children.length === 0) return [node];

                return node.children.flatMap(getLeaves);
            }

            const leaves = getLeaves(root);

            // Bottom y should be log2(number of leaves) * 70 (arbitrary value for spacing)
            const bottomY = Math.log2(leaves.length) * 70;
            const screenX = window.innerWidth;

            // Set the leaves evenly spaced along the x-axis
            const spacing = screenX / (leaves.length + 1);
            leaves.forEach((leaf, i) => {
                leaf.x = (i + 1) * spacing;
                leaf.y = bottomY;
            });

            function positionNodes(node) {
                if (node.x !== -1 && node.y !== -1) {
                    return;
                }
                if (node.children.length === 0) {
                    return alert('Error: Node without position or children.');
                }
                node.children.forEach(positionNodes);
                const midpointOfChildren = node.children.reduce((acc, child) => acc + child.x, 0) / node.children.length;
                node.x = midpointOfChildren;
                node.y = node.children[0].y - 50;
            }

            positionNodes(root);

            function getNodes(node) {
                return [node, ...node.children.flatMap(getNodes)];
            }

            const canvas = document.getElementById('graphCanvas');
            canvas.width = screenX;
            canvas.height = Math.round(bottomY) + 60; // Allow for all nodes to be visible + padding
            const ctx = canvas.getContext('2d');

            // Function to draw nodes
            function drawNodes(node) {
                node.children.forEach(child => {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(child.x, child.y);
                    ctx.stroke();
                });

                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = '#ddd'
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#000';
                ctx.stroke();
                ctx.textAlign = 'center';
                ctx.fillStyle = '#000';
                ctx.fillText(node.index + 1, node.x, node.y + 2); // Display index + 1

                node.children.forEach(drawNodes);
            }

            // Function to check if a point is inside a node
            function isPointInNode(x, y, node) {
                return Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2) < node.radius;
            }

            // Event listener for mouse clicks
            canvas.addEventListener('click', function (event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                getNodes(root).forEach(node => {
                    if (isPointInNode(x, y, node)) {
                        showMatchDetails(node.match);
                    }
                });
            });

            drawNodes(root);
        }


        function showMatchDetails(match) {
            const container = document.getElementById('container');
            container.style.display = 'flex';
            container.innerHTML = '';

            match.profiles.forEach((profile, idx) => {
                const card = document.createElement('div');
                card.className = 'card';
                if (idx === match.preferred_profile) {
                    card.classList.add('preferred');
                    card.innerHTML = `
                        <h2>Profile ${idx + 1} (Preferred)</h2>
                    `;
                } else {
                    card.innerHTML = `
                        <h2>Profile ${idx + 1}</h2>
                    `;
                }
                card.innerHTML += `
                    <p><strong>Domain:</strong> ${profile.profile.domain}</p>
                    <ul>
                        ${profile.profile.competencies.map(comp => `<li><strong>${comp.name}:</strong> ${comp.description}</li>`).join('')}
                    </ul>
                    <p><strong>Model:</strong> ${profile.model}</p>
                    <p><strong>Extraction Function:</strong> ${profile.extraction_function}</p>
                    <p><strong>Extraction Time:</strong> ${profile.extraction_time}s</p>
                    <p><strong>Number of Examples:</strong> ${profile.number_of_examples}</p>
                `;
                if (idx === match.preferred_profile) {
                    card.innerHTML += `<p><strong>Reasoning:</strong> ${match.reasoning}</p>
                    `;
                }
                container.appendChild(card);
            });
        }

        buildTree();
    </script>
</body>

</html>